{"version":3,"file":"xstate-actors.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/system.ts","../../src/utils.ts","../../src/createActor.ts","../../src/eventUtils.ts","../../src/actors/transition.ts","../../src/actors/callback.ts","../../src/actors/observable.ts","../../src/actors/promise.ts","../../src/actors/index.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if (!!(w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate macrotask.\n * It allows those errors to be detected by global error handlers and reported to bug tracking services\n * without interrupting our own stack of execution.\n *\n * @param err error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  Snapshot,\n  HomomorphicOmit,\n  EventObject,\n  AnyTransitionDefinition\n} from './types.ts';\n\nexport interface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\nexport interface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /**\n   * @internal\n   */\n  _bookId: () => string;\n  /**\n   * @internal\n   */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /**\n   * @internal\n   */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /**\n   * @internal\n   */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n  inspect: (observer: Observer<InspectionEvent>) => void;\n  /**\n   * @internal\n   */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /**\n   * @internal\n   */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /**\n   * @internal\n   */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const clock = options.clock;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      clock.clearTimeout(timeout);\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(\n      (observer) => observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observer) => {\n      inspectionObservers.add(observer);\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    }\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY } from './constants.ts';\nimport type {\n  AnyActorLogic,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  let result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nexport function toStateValue(\n  stateValue: StateLike<any> | StateValue\n): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nexport function toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([key, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nexport function isActorLogic(value: any): value is AnyActorLogic {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    'transition' in value &&\n    typeof value.transition === 'function'\n  );\n}\n\nexport function isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<any, any, any, any, any, any, any>)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\nexport type SnapshotListener<TLogic extends AnyActorLogic> = (\n  snapshot: SnapshotFrom<TLogic>\n) => void;\n\nexport type EventListener<TEvent extends EventObject = EventObject> = (\n  event: TEvent\n) => void;\n\nexport type Listener = () => void;\nexport type ErrorListener = (error: any) => void;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change its behavior based on the events it receives, which can cause effects outside of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /**\n   * The current internal state of the actor.\n   */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /**\n   * The unique identifier for this actor relative to its parent.\n   */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  private _systemId: string | undefined;\n\n  /**\n   * The globally unique process ID for this invocation.\n   */\n  public sessionId: string;\n\n  /**\n   * The system to which this actor belongs.\n   */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options, if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = logger;\n    this.clock = clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        if (!listeners) {\n          return;\n        }\n        for (const handler of Array.from(listeners)) {\n          handler(emittedEvent);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted. The observer can be:\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest snapshot\n   *\n   * @example\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   },\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object that has an `.unsubscribe()` method. You can call `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest snapshot, or an observer object whose `.next(snapshot)` method receives the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type']>(\n    type: TType,\n    handler: (emitted: EmittedFrom<TLogic> & { type: TType }) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners!.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /**\n   * Starts the Actor from the initial state\n   */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /**\n   * Stops the Actor and unsubscribe all listeners.\n   */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from {@link Actor.getSnapshot}. Persisted state represents the internal state of the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   *\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change.\n   * An actor may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with `fromCallback`, will not emit snapshots.\n   *\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\ntype RequiredOptions<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that actor system.\n *\n * @example\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine actor logic creator, see {@link createMachine}. Other actor logic creators include {@link fromCallback}, {@link fromEventObservable}, {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredOptions<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredOptions<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided options, if any.\n *\n * @deprecated Use `createActor` instead\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n */\nexport type Interpreter = typeof Actor;\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFrom,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFrom<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and received `event` object as arguments, and returns the next state, similar to a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial state argument, and is not the same as the State object of an actor or a state within a machine configuration.\n *\n * @param transition The transition function used to describe the transition logic. It should return the next state given the current state and event. It receives the following arguments:\n * - `state` - the current state.\n * - `event` - the received event.\n * - `actorScope` - the actor scope object, with properties like `self` and `system`.\n * @param initialContext The initial state of the transition function, either an object representing the state, or a function which returns a state object. If a function, it will receive as its only argument an object with the following properties:\n * - `input` - the `input` provided to its parent transition actor.\n * - `self` - a reference to its parent transition actor.\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n * @returns Actor logic\n *\n * @example\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1,\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 },\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<TransitionSnapshot<TContext>, TEvent, TSystem>\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(\n          snapshot.context,\n          event as TEvent,\n          actorScope as any\n        )\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFrom,\n  AnyActorRef,\n  AnyEventObject,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types';\n\ninterface CallbackInstanceState<TEvent extends EventObject> {\n  receivers: Set<(e: TEvent) => void> | undefined;\n  dispose: (() => void) | void;\n}\n\nconst instanceStates = /* #__PURE__ */ new WeakMap<\n  AnyActorRef,\n  CallbackInstanceState<any>\n>();\n\nexport type CallbackSnapshot<TInput> = Snapshot<undefined> & {\n  input: TInput;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n> = ActorLogic<\n  CallbackSnapshot<TInput>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  EventObject // TEmitted\n>;\n\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n> = ActorRefFrom<CallbackActorLogic<TEvent, TInput>>;\n\nexport type Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type InvokeCallback<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = NonReducibleUnknown\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive\n}: {\n  /**\n   * Data that was provided to the callback actor\n   * @see {@link https://stately.ai/docs/input | Input docs}\n   */\n  input: TInput;\n  /**\n   * The actor system to which the callback actor belongs\n   */\n  system: AnyActorSystem;\n  /**\n   * The parent actor of the callback actor\n   */\n  self: CallbackActorRef<TEvent>;\n  /**\n   * A function that can send events back to the parent actor\n   */\n  sendBack: (event: TSentEvent) => void;\n  /**\n   * A function that can be called with a listener function argument;\n   * the listener is then called whenever events are received by the callback actor\n   */\n  receive: Receiver<TEvent>;\n}) => (() => void) | void;\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @param invokeCallback - The callback function used to describe the callback logic\n * The callback function is passed an object with the following properties:\n * - `receive` - A function that can send events back to the parent actor; the listener is then called whenever events are received by the callback actor\n * - `sendBack` - A function that can send events back to the parent actor\n * - `input` - Data that was provided to the callback actor\n * - `self` - The parent actor of the callback actor\n * - `system` - The actor system to which the callback actor belongs\n * The callback function can (optionally) return a cleanup function, which is called when the actor is stopped.\n * @see {@link InvokeCallback} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n\n * @returns Callback logic\n *\n * @example\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n */\nexport function fromCallback<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n>(\n  invokeCallback: InvokeCallback<TEvent, AnyEventObject, TInput>\n): CallbackActorLogic<TEvent, TInput> {\n  const logic: CallbackActorLogic<TEvent, TInput> = {\n    config: invokeCallback,\n    start: (state, actorScope) => {\n      const { self, system } = actorScope;\n\n      const callbackState: CallbackInstanceState<TEvent> = {\n        receivers: undefined,\n        dispose: undefined\n      };\n\n      instanceStates.set(self, callbackState);\n\n      callbackState.dispose = invokeCallback({\n        input: state.input,\n        system,\n        self,\n        sendBack: (event) => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: (listener) => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        }\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState: CallbackInstanceState<TEvent> = instanceStates.get(\n        actorScope.self\n      )!;\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        callbackState.dispose?.();\n        return state;\n      }\n\n      callbackState.receivers?.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFrom,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot,\n  Subscribable,\n  Subscription\n} from '../types';\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\nexport type ObservableSnapshot<\n  TContext,\n  TInput extends NonReducibleUnknown\n> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservableActorLogic<\n  TContext,\n  TInput extends NonReducibleUnknown\n> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  AnyActorSystem,\n  EventObject // TEmitted\n>;\n\nexport type ObservableActorRef<TContext> = ActorRefFrom<\n  ObservableActorLogic<TContext, any>\n>;\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @param observableCreator A function that creates an observable. It receives one argument, an object with the following properties:\n * - `input` - Data that was provided to the observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the observable actor belongs\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import { fromObservable, createActor } from 'xstate'\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nexport function fromObservable<TContext, TInput extends NonReducibleUnknown>(\n  observableCreator: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput> {\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput> = {\n    config: observableCreator,\n    transition: (snapshot, event, { self, id, defer, system }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...state }) => state,\n    restoreSnapshot: (state) => ({\n      ...(state as any),\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers event objects.\n *\n * Event observable actor logic is described by an observable stream of {@link https://stately.ai/docs/transitions#event-objects | event objects}. Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @param lazyObservable A function that creates an observable that delivers event objects. It receives one argument, an object with the following properties:\n *\n * - `input` - Data that was provided to the event observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the event observable actor belongs.\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(() =>\n *   fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic,\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n */\nexport function fromEventObservable<\n  T extends EventObject,\n  TInput extends NonReducibleUnknown\n>(\n  lazyObservable: ({\n    input,\n    system\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<T>;\n  }) => Subscribable<T>\n): ObservableActorLogic<T, TInput> {\n  // TODO: event types\n  const logic: ObservableActorLogic<T, TInput> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...snapshot }) => snapshot,\n    restoreSnapshot: (snapshot: any) => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFrom,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\nexport type PromiseActorLogic<TOutput, TInput = unknown> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  AnyActorSystem,\n  EventObject // TEmitted\n>;\n\nexport type PromiseActorRef<TOutput> = ActorRefFrom<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\n/**\n * An actor logic creator which returns promise logic as defined by an async process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @param promiseCreator\n *   A function which returns a Promise, and accepts an object with the following properties:\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n *\n * @example\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...')\n *     .then((data) => data.json());\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n */\nexport function fromPromise<TOutput, TInput = NonReducibleUnknown>(\n  promiseCreator: ({\n    input,\n    system\n  }: {\n    /**\n     * Data that was provided to the promise actor\n     */\n    input: TInput;\n    /**\n     * The actor system to which the promise actor belongs\n     */\n    system: AnyActorSystem;\n    /**\n     * The parent actor of the promise actor\n     */\n    self: PromiseActorRef<TOutput>;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput> {\n  const logic: PromiseActorLogic<TOutput, TInput> = {\n    config: promiseCreator,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({ input: state.input!, system, self })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_RESOLVE,\n            data: response\n          });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_REJECT,\n            data: errorData\n          });\n        }\n      );\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackSnapshot\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","createScheduledEventId","actorRef","id","sessionId","idCounter","toObserver","nextHandler","errorHandler","completionHandler","isObserver","undefined","bind","error","complete","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","Set","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","_systemId","system","_doneEvent","src","_deferred","resolvedOptions","parent","syncSnapshot","systemId","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","target","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","snapshot","_bookId","_register","set","_unregister","delete","get","_set","existing","Error","observer","add","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","type","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","createSystem","defer","push","stopChild","child","_stop","emit","emittedEvent","listeners","handler","Array","from","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","input","output","update","deferredFn","shift","length","_stopProcedure","_complete","invokeId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","unsubscribe","on","wrappedHandler","Running","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","fromTransition","initialContext","config","actorScope","context","_","instanceStates","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","emptyLogic","createActor","invokeCallback","callbackState","receivers","dispose","sendBack","receive","listener","receiver","lazyObservable","data","_subscription","observableCreator","promiseCreator","resolvedValue","Promise","resolve","then","response","errorData"],"mappings":"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"}