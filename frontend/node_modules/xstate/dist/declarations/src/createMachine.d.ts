import { StateMachine } from "./StateMachine.js";
import { ResolveTypegenMeta, TypegenConstraint, TypegenDisabled } from "./typegenTypes.js";
import { AnyActorRef, EventObject, AnyEventObject, Cast, InternalMachineImplementations, IsNever, MachineConfig, MachineContext, MachineTypes, NonReducibleUnknown, ParameterizedObject, Prop, ProvidedActor, StateValue, ToChildren } from "./types.js";
type TestValue = string | {
    [k: string]: TestValue | undefined;
};
type _GroupTestValues<TTestValue extends string | TestValue> = TTestValue extends string ? TTestValue extends `${string}.${string}` ? [never, never] : [TTestValue, never] : [never, TTestValue];
type GroupTestValues<TTestValue extends string | TestValue> = {
    leafCandidates: _GroupTestValues<TTestValue>[0];
    nonLeaf: _GroupTestValues<TTestValue>[1];
};
type FilterLeafValues<TLeafCandidate extends string, TNonLeaf extends {
    [k: string]: TestValue | undefined;
}> = IsNever<TNonLeaf> extends true ? TLeafCandidate : TLeafCandidate extends string ? TLeafCandidate extends keyof TNonLeaf ? never : TLeafCandidate : never;
type ToStateValue<TTestValue extends string | TestValue> = FilterLeafValues<GroupTestValues<TTestValue>['leafCandidates'], GroupTestValues<TTestValue>['nonLeaf']> | (IsNever<GroupTestValues<TTestValue>['nonLeaf']> extends false ? {
    [K in keyof GroupTestValues<TTestValue>['nonLeaf']]: ToStateValue<NonNullable<GroupTestValues<TTestValue>['nonLeaf'][K]>>;
} : never);
/**
 * Creates a state machine (statechart) with the given configuration.
 *
 * The state machine represents the pure logic of a state machine actor.
 *
 * @param config The state machine configuration.
 * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })` to provide machine implementations instead.
 *
 * @example
  ```ts
  import { createMachine } from 'xstate';

  const lightMachine = createMachine({
    id: 'light',
    initial: 'green',
    states: {
      green: {
        on: {
          TIMER: { target: 'yellow' }
        }
      },
      yellow: {
        on: {
          TIMER: { target: 'red' }
        }
      },
      red: {
        on: {
          TIMER: { target: 'green' }
        }
      }
    }
  });

  const lightActor = createActor(lightMachine);
  lightActor.start();

  lightActor.send({ type: 'TIMER' });
  ```
 */
export declare function createMachine<TContext extends MachineContext, TEvent extends AnyEventObject, // TODO: consider using a stricter `EventObject` here
TActor extends ProvidedActor, TAction extends ParameterizedObject, TGuard extends ParameterizedObject, TDelay extends string, TTag extends string, TInput, TOutput extends NonReducibleUnknown, TEmitted extends EventObject, TTypesMeta extends TypegenConstraint = TypegenDisabled>(config: {
    types?: MachineTypes<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, TInput, TOutput, TEmitted, TTypesMeta>;
    schemas?: unknown;
} & MachineConfig<TContext, TEvent, TActor, TAction, TGuard, TDelay, TTag, TInput, TOutput, TEmitted, TTypesMeta>, implementations?: InternalMachineImplementations<TContext, ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag, TEmitted>>): StateMachine<TContext, TEvent, Cast<ToChildren<TActor>, Record<string, AnyActorRef | undefined>>, TActor, TAction, TGuard, TDelay, 'matchesStates' extends keyof TTypesMeta ? ToStateValue<Cast<TTypesMeta['matchesStates'], TestValue>> : StateValue, Prop<ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag, TEmitted>['resolved'], 'tags'> & string, TInput, TOutput, TEmitted, ResolveTypegenMeta<TTypesMeta, TEvent, TActor, TAction, TGuard, TDelay, TTag, TEmitted>>;
export {};
